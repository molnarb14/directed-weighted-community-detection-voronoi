#v2023.0207
#generating weighted networks using the base binary networks generated by the LFR algorithm

import numpy as np
import sys
import random
import os

xmin = .01

def calculateModularity(matrix, size, clustering, idegree, odegree):
    m = sum(w for w in matrix.ravel() if w > 0)

    q = 0

    for i in range(0, size):
        for j in range(0, size):
            k_i = odegree[i] #outdegree
            k_j = idegree[j] #indegree
            q += (matrix[i][j]/m - (k_i * k_j)/(m * m)) * (1 if abs(clustering[i]) == abs(clustering[j]) else 0) #generator points appear with minus sign, thus abs() is needed
    return q

def generateWeight(distributionParameter, distributionType):
    if(distributionType == "power"):
        while True:
            weight = np.random.power(distributionParameter)
            if(weight >= xmin):
                return weight
    else:
        while True:
            weight = np.random.normal(distributionParameter, .1)
            if(weight > 0):
                return weight
    

if len(sys.argv) != 9:
    print("Usage python {} [N] [k] [mu] [dtype] [ins] [outs] [start] [total]".format(sys.argv[0]))
    print("     [N]: network size")
    print("     [k]: average degree")
    print("     [mu]: mixing parameter (wo decimal dot and w 2 decimals, eg. for 0.1 write 010)")
    print("     [dtype]: edgeweight distribution type (normal or power)")
    print("     [ins]: parameter value for distribution of links inside clusters (wo decimal dot and w 2 decimals, eg. for 0.1 write 010)")
    print("     [outs]: parameter value for distribution of links between clusters (wo decimal dot and w 2 decimals, eg. for 0.1 write 010)")
    print("     [start]: start sequence number")
    print("     [total]: number of networks to be generated")
    sys.exit(1)

N = int(sys.argv[1])
k = int(sys.argv[2])

_mu = sys.argv[3]
dtype = sys.argv[4]
_ins = sys.argv[5]
_outs = sys.argv[6]

start = int(sys.argv[7])
total = int(sys.argv[8])

if not os.path.exists("benchmarks/N{}_k{}_mu{}_{}{}{}".format(N, k, _mu, dtype, _ins, _outs)):
    os.makedirs("benchmarks/N{}_k{}_mu{}_{}{}{}".format(N, k, _mu, dtype, _ins, _outs))

if(len(_mu) == 2):
    mu = float(_mu[0] + "." + _mu[1])
else:
    mu = float(_mu[0] + "." + _mu[1] + _mu[2])
if(len(_ins) == 2):
    ins = float(_ins[0] + "." + _ins[1])
else:
    ins = float(_ins[0] + "." + _ins[1] + _ins[2])
if(len(_outs) == 2):
    outs = float(_outs[0] + "." + _outs[1])
else:
    outs = float(_outs[0] + "." + _outs[1] + _outs[2])

dparam = ""

for index in range(start, total + 1):
    edgelist = np.loadtxt("generator/N{}_k{}_base_mu{}/network_{}.txt".format(N, k, _mu, index), dtype=int)
    totalEdges = len(edgelist)
    
    indeces, community = np.loadtxt("generator/N{}_k{}_base_mu{}/community_{}.txt".format(N, k, _mu, index), dtype=int, unpack=True)
    clusterNumber = np.max(community)

    nweights = np.zeros(totalEdges) #edge list with normal weight distribution
    pweights = np.zeros(totalEdges) #edge list with power weight distribution

    insMeanN = 0
    outsMeanN = 0
    insCounterN = 0
    outsCounterN = 0

    insMeanP = 0
    outsMeanP = 0
    insCounterP = 0
    outsCounterP = 0

    for eindex, (_x, _y) in enumerate(edgelist):           
        src = _x - 1
        tgt = _y - 1

        if(community[src] == community[tgt]):
            dparam = ins
        else:
            dparam = outs

        weight = generateWeight(dparam, dtype)
        nweights[eindex] = weight

    with open("benchmarks/N{}_k{}_mu{}_{}{}{}/test_{}.txt".format(N, k, _mu, dtype, _ins, _outs, index), "w") as f:
        for eindex, (_x, _y) in enumerate(edgelist):
            f.write("{}\t{}\t{:.8f}\n".format(_x, _y, nweights[eindex]))
